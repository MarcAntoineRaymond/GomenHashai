apiVersion: v1
kind: Pod
metadata:
  name: {{ include "gomenhashai.fullname" . }}-test
  labels:
    {{- include "gomenhashai.labels" . | nindent 4 }}
  annotations:
    "helm.sh/hook": test
spec:
  containers:
    - name: tester
      image: "{{ .Values.tests.image.repository }}:{{ .Values.tests.image.tag }}@{{ .Values.tests.image.digest }}"
      command:
      - sh
      args:
      - -c
      - |
        kubectl wait --for=condition=ready pod -l app.kubernetes.io/name={{ include "gomenhashai.name" . }} -n {{ .Release.Namespace }} --timeout=60s || exit 1
        # Wait webhook is ready
        sleep 60
        # Test webhook
        if ! kubectl run test-{{ include "gomenhashai.name" . }} -n default --image=test 2> /tmp/out.txt ; then
          if ! grep 'Error from server (Forbidden): admission webhook "vpod-v1.kb.io" denied the request: Pod "test-{{ include "gomenhashai.name" . }}" is forbidden' /tmp/out.txt ; then
            cat /tmp/out.txt
            exit 1
          fi
        fi
        if ! kubectl run test-{{ include "gomenhashai.name" . }} -n default --image="docker.io/library/busybox:stable" ; then
          echo "Pod using trusted image should be allowed but was denied"
          exit 1
        fi

        kubectl delete pod test-{{ include "gomenhashai.name" . }} -n default
        
        {{- if .Values.config }}
        {{- if .Values.config.existingPods }}
        {{- if ne .Values.config.existingPods.enabled false }}
        # Test handle existing pods at startup
        # A pod test-delete is expected to exist prior deployment, using an untrusted image
        kubectl get pod -n default test-delete && echo "Pod test-delete should have been deleted" && exit 1
        # A pod test-not-delete is expected to exist prior deployment, using a trusted image
        ! kubectl get pod -n default test-not-delete && echo "Pod test-not-delete should not have been deleted" && exit 1 || exit 0
        {{- end }}
        {{- end }}
        {{- end }}

        {{- if .Values.globalPullSecrets }}
        SECRET_NAME={{ index .Values.globalPullSecrets 0 "name" }}
        namespaces=$(kubectl get ns -o jsonpath='{.items[*].metadata.name}')

        for ns in $namespaces; do
          if ! kubectl get secret "${SECRET_NAME}" -n "$ns"; then
            echo "Secret ${SECRET_NAME} not found in namespace ${ns}"
            exit 1
          fi
        done

        test_ns="test-ns-$(date +%s)"
        kubectl create ns "$test_ns"

        for i in {1..30}; do
          if kubectl get secret "${SECRET_NAME}" -n "$test_ns" &>/dev/null; then
            echo "Secret created in new namespace"
          fi
          sleep 2
        done

        if ! kubectl get secret "${SECRET_NAME}" -n "$test_ns" &>/dev/null; then
          echo "Secret was not created in new namespace ${test_ns} within timeout"
          exit 1
        fi
        {{- end }}
      volumeMounts:
        - name: tmp
          mountPath: /tmp
      resources:
        {{- toYaml .Values.resources | nindent 8 }}
      securityContext:
        {{- toYaml .Values.containerSecurityContext | nindent 8 }}
  volumes:
    - name: tmp
      emptyDir: {}
  securityContext:
    {{- toYaml .Values.podSecurityContext | nindent 4 }}
  serviceAccountName: {{ include "gomenhashai.serviceAccountName" . }}
  restartPolicy: Never